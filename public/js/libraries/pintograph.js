var t={d:(o,i)=>{for(var n in i)t.o(i,n)&&!t.o(o,n)&&Object.defineProperty(o,n,{enumerable:!0,get:i[n]})},o:(t,o)=>Object.prototype.hasOwnProperty.call(t,o)},o={};t.d(o,{D_:()=>l,Gm:()=>u,xs:()=>T,K4:()=>m,z1:()=>P,AK:()=>A,eh:()=>S,LI:()=>i});const i={sine:t=>.5*Math.sin(t*Math.PI*2)+.5,triangle:t=>{let o=t-Math.floor(t);return o<.5?2*o:2*(1-o)},sawtooth:t=>t-Math.floor(t),step:t=>t-Math.floor(t)<.5?1:0};function n(){return new Float32Array([1,0,0,0,1,0,0,0,1])}function s(t,o,i){return t.fill(0),t[0]=1,t[4]=1,t[6]=o,t[7]=i,t[8]=1,t}function e(t,o){let i=Math.cos(o),n=Math.sin(o);return t.fill(0),t[0]=i,t[1]=n,t[3]=-n,t[4]=i,t[8]=1,t}function r(t,o,i){let n=o[0],s=o[1],e=o[2],r=o[3],h=o[4],a=o[5],l=o[6],u=o[7],m=o[8],d=i[0],f=i[1],c=i[2],x=i[3],y=i[4],g=i[5],w=i[6],p=i[7],P=i[8];return t[0]=d*n+f*r+c*l,t[1]=d*s+f*h+c*u,t[2]=d*e+f*a+c*m,t[3]=x*n+y*r+g*l,t[4]=x*s+y*h+g*u,t[5]=x*e+y*a+g*m,t[6]=w*n+p*r+P*l,t[7]=w*s+p*h+P*u,t[8]=w*e+p*a+P*m,t}function h(t,o,i){let n=o.x,s=o.y;return t.x=i[0]*n+i[3]*s+i[6],t.y=i[1]*n+i[4]*s+i[7],t}function a(t,o){let i=[{x:2,y:6},{x:2,y:2},{x:6,y:2},{x:6,y:-2},{x:2,y:-2},{x:2,y:-6},{x:-2,y:-6},{x:-2,y:-2},{x:-6,y:-2},{x:-6,y:2},{x:-2,y:2},{x:-2,y:6},{x:2,y:6}];t.beginPath();for(let n=0;n<i.length;++n)h(i[n],i[n],o),0===n?t.moveTo(i[n].x,i[n].y):t.lineTo(i[n].x,i[n].y);t.stroke()}class l{constructor(t,o,s,e,r="#888888",h){this.mountedAt=t,this.length=o,this.angle=s,this.speed=e,this.strokeStyle=r,this.mountPoint={transformation:n()},this.currentPosition=0,this.localRotation=n(),this.localTranslation=n(),this.localTransformation=n(),this.easingFunction=h||i.sine}step(t,o){this.currentPosition=this.easingFunction(t*this.speed)*this.length-.5*this.length,e(this.localRotation,this.angle),s(this.localTranslation,this.currentPosition,0),r(this.localTransformation,this.localRotation,this.localTranslation),r(this.mountPoint.transformation,this.mountedAt.transformation,this.localTransformation)}drawDebug(t){let o={x:-this.length/2-this.currentPosition,y:0},i={x:this.length/2-this.currentPosition,y:0};h(o,o,this.mountPoint.transformation),h(i,i,this.mountPoint.transformation),t.beginPath(),t.moveTo(o.x,o.y),t.lineTo(i.x,i.y),t.strokeStyle=this.strokeStyle,t.stroke(),a(t,this.mountPoint.transformation)}}class u{constructor(t,o,i){this.mountedAt=t,this.lineWidth=1,this.shadowBlur=0,this.shadowColor=()=>"black",this.worldPosition={x:0,y:0},this.drawBuffer=[],this.color="string"==typeof o?()=>o:o,i&&(i.lineWidth&&(this.lineWidth=i.lineWidth),i.shadowBlur&&(this.shadowBlur=i.shadowBlur),i.shadowColor&&(this.shadowColor="string"==typeof i.shadowColor?()=>i.shadowColor:i.shadowColor))}step(t,o){h(this.worldPosition,{x:0,y:0},this.mountedAt.transformation),this.drawBuffer.push(Object.assign(Object.assign({},this.worldPosition),{color:this.color(t),shadowColor:this.shadowColor(t)}))}drawDebug(t){}draw(t){if(this.drawBuffer.length>1){t.beginPath(),t.moveTo(this.drawBuffer[0].x,this.drawBuffer[0].y);for(let o=1;o<this.drawBuffer.length;++o)t.lineTo(this.drawBuffer[o].x,this.drawBuffer[o].y);t.strokeStyle=this.drawBuffer[0].color,t.lineWidth=this.lineWidth,t.shadowBlur=this.shadowBlur,t.shadowColor=this.drawBuffer[0].shadowColor,t.stroke(),this.drawBuffer=[this.drawBuffer[this.drawBuffer.length-1]]}}}class m{constructor(t,o){this.transformation=n(),this.localTransformation=n(),this.sceneTransformation=null!=o?o:n(),s(this.localTransformation,t.x,t.y)}step(t,o){r(this.transformation,this.localTransformation,this.sceneTransformation)}drawDebug(t){a(t,this.transformation)}}function d(t,o){var i=o.x-t.x,n=o.y-t.y;return Math.sqrt(Math.pow(i,2)+Math.pow(n,2))}function f(t){var o=d({x:0,y:0},t);return 0==o?{x:0,y:0}:{x:t.x/o,y:t.y/o}}function c(t,o){return{x:t.x*o,y:t.y*o}}function x(t,o){return{x:t.x+o.x,y:t.y+o.y}}function y(t,o){return x(t,{x:-o.x,y:-o.y})}function g(t){return Math.atan2(t.y,t.x)}const w=1e-4;function p(t,o,i,n){var s=d(t,i);if(s>o+n)throw new Error("Circles are separate");if(s<Math.abs(o-n))throw new Error("Circles are contained within each other");if(0===s&&o===n)throw new Error("Circles are coincident");var e=(Math.pow(o,2)-Math.pow(n,2)+Math.pow(s,2))/(2*s),r=Math.sqrt(Math.pow(o,2)-Math.pow(e,2)),h=t.x+e*(i.x-t.x)/s,a=t.y+e*(i.y-t.y)/s;return[{x:h+r*(i.y-t.y)/s,y:a-r*(i.x-t.x)/s},{x:h-r*(i.y-t.y)/s,y:a+r*(i.x-t.x)/s}]}Math.PI;class P{constructor(t,o="#888888"){this.strokeStyle=o,this.mountPoint={transformation:n()},this.mountedAt1WS={x:0,y:0},this.mountedAt2WS={x:0,y:0},this.mountPointTranslation=n(),this.mountPointRotation=n(),this.mountedAt1=t.mountedAt1,this.mountedAt2=t.mountedAt2,this.length1=t.length1,this.length2=t.length2,this.flip=t.flip}step(t,o){h(this.mountedAt1WS,{x:0,y:0},this.mountedAt1.transformation),h(this.mountedAt2WS,{x:0,y:0},this.mountedAt2.transformation);let i=d(this.mountedAt1WS,this.mountedAt2WS);if(i<w)throw new Error("Mount points are placed too close to each other.");if(i>this.length1+this.length2)throw new Error("Arms are too short.");let n=p(this.mountedAt1WS,this.length1,this.mountedAt2WS,this.length2),a=this.flip?n[1]:n[0],l=g(y(a,this.mountedAt1WS));e(this.mountPointRotation,l),s(this.mountPointTranslation,a.x,a.y),r(this.mountPoint.transformation,this.mountPointTranslation,this.mountPointRotation)}drawDebug(t){let o={x:0,y:0};h(o,{x:0,y:0},this.mountPoint.transformation),t.beginPath(),t.moveTo(this.mountedAt1WS.x,this.mountedAt1WS.y),t.lineTo(o.x,o.y),t.lineTo(this.mountedAt2WS.x,this.mountedAt2WS.y),t.lineWidth=3,t.strokeStyle=this.strokeStyle,t.stroke(),t.lineWidth=1,a(t,this.mountPoint.transformation)}}class A{constructor(t,o,i,s,e="#888888"){this.mountedAt=t,this.radius=o,this.startAngle=i,this.speed=s,this.strokeStyle=e,this.currentAngle=i,this.rotationMatrix=n(),this.translationMatrix=n(),this.localTransformation=n(),this.mountPoint={transformation:n()}}step(t,o){this.currentAngle=(this.startAngle+2*Math.PI*this.speed*t)%(2*Math.PI),e(this.rotationMatrix,this.currentAngle),s(this.translationMatrix,this.radius,0),r(this.localTransformation,this.rotationMatrix,this.translationMatrix),r(this.mountPoint.transformation,this.mountedAt.transformation,this.localTransformation)}drawDebug(t){let o={x:0,y:0};h(o,o,this.mountedAt.transformation),t.beginPath(),t.arc(o.x,o.y,this.radius,0,2*Math.PI),t.strokeStyle=this.strokeStyle,t.stroke(),a(t,this.mountPoint.transformation)}}class S{constructor(t,o="#888888"){this.strokeStyle=o,this.mountPoint1={transformation:n()},this.mountPoint2={transformation:n()},this.mountedAt1WS={x:0,y:0},this.mountedAt2WS={x:0,y:0},this.mountPoint1Translation=n(),this.mountPoint2Translation=n(),this.mountPoint1Rotation=n(),this.mountPoint2Rotation=n(),this.mountedAt1=t.mountedAt1,this.mountedAt2=t.mountedAt2,this.length1=t.length1,this.length2=t.length2,this.extensionLength1=t.extensionLength1,this.extensionLength2=t.extensionLength2,this.flip=t.flip}step(t,o){h(this.mountedAt1WS,{x:0,y:0},this.mountedAt1.transformation),h(this.mountedAt2WS,{x:0,y:0},this.mountedAt2.transformation);let i=d(this.mountedAt1WS,this.mountedAt2WS);if(i<w)throw new Error("Mount points are placed too close to each other.");if(i>this.length1+this.length2)throw new Error("Arms are too short.");let n=p(this.mountedAt1WS,this.length1,this.mountedAt2WS,this.length2),a=this.flip?n[1]:n[0],l=y(a,this.mountedAt1WS),u=y(a,this.mountedAt2WS),m=c(f(l),this.length1+this.extensionLength1),P=c(f(u),this.length2+this.extensionLength2),A=x(this.mountedAt1WS,m),S=x(this.mountedAt2WS,P),T=y(A,this.mountedAt1WS),W=y(S,this.mountedAt2WS),M=g(T),b=g(W);e(this.mountPoint1Rotation,M),e(this.mountPoint2Rotation,b),s(this.mountPoint1Translation,A.x,A.y),s(this.mountPoint2Translation,S.x,S.y),r(this.mountPoint1.transformation,this.mountPoint1Translation,this.mountPoint1Rotation),r(this.mountPoint2.transformation,this.mountPoint2Translation,this.mountPoint2Rotation)}drawDebug(t){let o={x:0,y:0},i={x:0,y:0};h(o,{x:0,y:0},this.mountPoint1.transformation),h(i,{x:0,y:0},this.mountPoint2.transformation),t.beginPath(),t.moveTo(this.mountedAt1WS.x,this.mountedAt1WS.y),t.lineTo(o.x,o.y),t.moveTo(this.mountedAt2WS.x,this.mountedAt2WS.y),t.lineTo(i.x,i.y),t.lineWidth=3,t.strokeStyle=this.strokeStyle,t.stroke(),t.lineWidth=1,a(t,this.mountPoint1.transformation),a(t,this.mountPoint2.transformation)}}class T{constructor(t,o){this.renderContext=t,this.contraptionRenderContext=o,this.objects=[],this.pens=[],this.stepsPerFrame=10,this.frameTime=1/60,this._isRunning=!1,this.simulationTime=0,this.previousStepTimestamp=0}run(){this._isRunning||(this._isRunning=!0,this.processFrame())}stop(){this._isRunning=!1}reset(){this.stop(),this.simulationTime=0,this.previousStepTimestamp=0}get isRunning(){return this._isRunning}processFrame(){this._isRunning&&setTimeout(this.processFrame.bind(this),1e3*this.frameTime);for(let t=0;t<this.stepsPerFrame;++t)this.step(this.simulationTime),this.simulationTime+=this.frameTime/this.stepsPerFrame;this.draw(this.renderContext),this.contraptionRenderContext&&this.drawDebug(this.contraptionRenderContext)}step(t){let o=t-this.previousStepTimestamp;this.previousStepTimestamp=t;for(let i=0;i<this.objects.length;++i)this.objects[i].step(t,o);for(let i=0;i<this.pens.length;++i)this.pens[i].step(t,o)}draw(t){for(let o=0;o<this.pens.length;++o)this.pens[o].draw(t)}drawDebug(t){t.clearRect(0,0,t.canvas.width,t.canvas.height);for(let o=0;o<this.objects.length;++o)this.objects[o].drawDebug(t)}}var W=o.D_,M=o.Gm,b=o.xs,R=o.K4,k=o.z1,v=o.AK,B=o.eh,C=o.LI;export{W as Oscillator,M as Pen,b as Scene,R as StaticMountPoint,k as VArm,v as Wheel,B as XArm,C as easingFunctions};