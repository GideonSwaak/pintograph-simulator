var t={d:(i,o)=>{for(var n in o)t.o(o,n)&&!t.o(i,n)&&Object.defineProperty(i,n,{enumerable:!0,get:o[n]})},o:(t,i)=>Object.prototype.hasOwnProperty.call(t,i)},i={};t.d(i,{D_:()=>l,Gm:()=>u,xs:()=>S,K4:()=>m,z1:()=>P,AK:()=>A,eh:()=>T,LI:()=>o});const o={sine:t=>.5*Math.sin(t*Math.PI*2)+.5,triangle:t=>{let i=t-Math.floor(t);return i<.5?2*i:2*(1-i)},sawtooth:t=>t-Math.floor(t),step:t=>t-Math.floor(t)<.5?1:0};function n(){return new Float32Array([1,0,0,0,1,0,0,0,1])}function s(t,i,o){return t.fill(0),t[0]=1,t[4]=1,t[6]=i,t[7]=o,t[8]=1,t}function e(t,i){let o=Math.cos(i),n=Math.sin(i);return t.fill(0),t[0]=o,t[1]=n,t[3]=-n,t[4]=o,t[8]=1,t}function r(t,i,o){let n=i[0],s=i[1],e=i[2],r=i[3],h=i[4],a=i[5],l=i[6],u=i[7],m=i[8],d=o[0],f=o[1],c=o[2],x=o[3],y=o[4],g=o[5],w=o[6],p=o[7],P=o[8];return t[0]=d*n+f*r+c*l,t[1]=d*s+f*h+c*u,t[2]=d*e+f*a+c*m,t[3]=x*n+y*r+g*l,t[4]=x*s+y*h+g*u,t[5]=x*e+y*a+g*m,t[6]=w*n+p*r+P*l,t[7]=w*s+p*h+P*u,t[8]=w*e+p*a+P*m,t}function h(t,i,o){let n=i.x,s=i.y;return t.x=o[0]*n+o[3]*s+o[6],t.y=o[1]*n+o[4]*s+o[7],t}function a(t,i){let o=[{x:2,y:6},{x:2,y:2},{x:6,y:2},{x:6,y:-2},{x:2,y:-2},{x:2,y:-6},{x:-2,y:-6},{x:-2,y:-2},{x:-6,y:-2},{x:-6,y:2},{x:-2,y:2},{x:-2,y:6},{x:2,y:6}];t.beginPath();for(let n=0;n<o.length;++n)h(o[n],o[n],i),0===n?t.moveTo(o[n].x,o[n].y):t.lineTo(o[n].x,o[n].y);t.stroke()}class l{constructor(t,i,s,e,r){this.mountedAt=t,this.length=i,this.angle=s,this.speed=e,this.mountPoint={transformation:n()},this.currentPosition=0,this.localRotation=n(),this.localTranslation=n(),this.localTransformation=n(),this.easingFunction=r||o.sine}step(t,i){this.currentPosition=this.easingFunction(t*this.speed)*this.length-.5*this.length,e(this.localRotation,this.angle),s(this.localTranslation,this.currentPosition,0),r(this.localTransformation,this.localRotation,this.localTranslation),r(this.mountPoint.transformation,this.mountedAt.transformation,this.localTransformation)}drawDebug(t){let i={x:-this.length/2-this.currentPosition,y:0},o={x:this.length/2-this.currentPosition,y:0};h(i,i,this.mountPoint.transformation),h(o,o,this.mountPoint.transformation),t.beginPath(),t.moveTo(i.x,i.y),t.lineTo(o.x,o.y),t.strokeStyle="#555555",t.stroke(),a(t,this.mountPoint.transformation)}}class u{constructor(t,i,o){this.mountedAt=t,this.lineWidth=1,this.shadowBlur=0,this.shadowColor=()=>"black",this.worldPosition={x:0,y:0},this.drawBuffer=[],this.color="string"==typeof i?()=>i:i,o&&(o.lineWidth&&(this.lineWidth=o.lineWidth),o.shadowBlur&&(this.shadowBlur=o.shadowBlur),o.shadowColor&&(this.shadowColor="string"==typeof o.shadowColor?()=>o.shadowColor:o.shadowColor))}step(t,i){h(this.worldPosition,{x:0,y:0},this.mountedAt.transformation),this.drawBuffer.push(Object.assign(Object.assign({},this.worldPosition),{color:this.color(t),shadowColor:this.shadowColor(t)}))}drawDebug(t){}draw(t){if(this.drawBuffer.length>1){t.beginPath(),t.moveTo(this.drawBuffer[0].x,this.drawBuffer[0].y);for(let i=1;i<this.drawBuffer.length;++i)t.lineTo(this.drawBuffer[i].x,this.drawBuffer[i].y);t.strokeStyle=this.drawBuffer[0].color,t.lineWidth=this.lineWidth,t.shadowBlur=this.shadowBlur,t.shadowColor=this.drawBuffer[0].shadowColor,t.stroke(),this.drawBuffer=[this.drawBuffer[this.drawBuffer.length-1]]}}}class m{constructor(t,i){this.transformation=n(),this.localTransformation=n(),this.sceneTransformation=null!=i?i:n(),s(this.localTransformation,t.x,t.y)}step(t,i){r(this.transformation,this.localTransformation,this.sceneTransformation)}drawDebug(t){a(t,this.transformation)}}function d(t,i){var o=i.x-t.x,n=i.y-t.y;return Math.sqrt(Math.pow(o,2)+Math.pow(n,2))}function f(t){var i=d({x:0,y:0},t);return 0==i?{x:0,y:0}:{x:t.x/i,y:t.y/i}}function c(t,i){return{x:t.x*i,y:t.y*i}}function x(t,i){return{x:t.x+i.x,y:t.y+i.y}}function y(t,i){return x(t,{x:-i.x,y:-i.y})}function g(t){return Math.atan2(t.y,t.x)}const w=1e-4;function p(t,i,o,n){var s=d(t,o);if(s>i+n)throw new Error("Circles are separate");if(s<Math.abs(i-n))throw new Error("Circles are contained within each other");if(0===s&&i===n)throw new Error("Circles are coincident");var e=(Math.pow(i,2)-Math.pow(n,2)+Math.pow(s,2))/(2*s),r=Math.sqrt(Math.pow(i,2)-Math.pow(e,2)),h=t.x+e*(o.x-t.x)/s,a=t.y+e*(o.y-t.y)/s;return[{x:h+r*(o.y-t.y)/s,y:a-r*(o.x-t.x)/s},{x:h-r*(o.y-t.y)/s,y:a+r*(o.x-t.x)/s}]}Math.PI;class P{constructor(t){this.mountPoint={transformation:n()},this.mountedAt1WS={x:0,y:0},this.mountedAt2WS={x:0,y:0},this.mountPointTranslation=n(),this.mountPointRotation=n(),this.mountedAt1=t.mountedAt1,this.mountedAt2=t.mountedAt2,this.length1=t.length1,this.length2=t.length2,this.flip=t.flip}step(t,i){h(this.mountedAt1WS,{x:0,y:0},this.mountedAt1.transformation),h(this.mountedAt2WS,{x:0,y:0},this.mountedAt2.transformation);let o=d(this.mountedAt1WS,this.mountedAt2WS);if(o<w)throw new Error("Mount points are placed too close to each other.");if(o>this.length1+this.length2)throw new Error("Arms are too short.");let n=p(this.mountedAt1WS,this.length1,this.mountedAt2WS,this.length2),a=this.flip?n[1]:n[0],l=g(y(a,this.mountedAt1WS));e(this.mountPointRotation,l),s(this.mountPointTranslation,a.x,a.y),r(this.mountPoint.transformation,this.mountPointTranslation,this.mountPointRotation)}drawDebug(t){let i={x:0,y:0};h(i,{x:0,y:0},this.mountPoint.transformation),t.beginPath(),t.moveTo(this.mountedAt1WS.x,this.mountedAt1WS.y),t.lineTo(i.x,i.y),t.lineTo(this.mountedAt2WS.x,this.mountedAt2WS.y),t.lineWidth=3,t.strokeStyle="lime",t.stroke(),t.lineWidth=1,a(t,this.mountPoint.transformation)}}class A{constructor(t,i,o,s){this.mountedAt=t,this.radius=i,this.startAngle=o,this.speed=s,this.currentAngle=o,this.rotationMatrix=n(),this.translationMatrix=n(),this.localTransformation=n(),this.mountPoint={transformation:n()}}step(t,i){this.currentAngle=(this.startAngle+2*Math.PI*this.speed*t)%(2*Math.PI),e(this.rotationMatrix,this.currentAngle),s(this.translationMatrix,this.radius,0),r(this.localTransformation,this.rotationMatrix,this.translationMatrix),r(this.mountPoint.transformation,this.mountedAt.transformation,this.localTransformation)}drawDebug(t){let i={x:0,y:0};h(i,i,this.mountedAt.transformation),t.beginPath(),t.arc(i.x,i.y,this.radius,0,2*Math.PI),t.strokeStyle="#888888",t.stroke(),a(t,this.mountPoint.transformation)}}class T{constructor(t){this.mountPoint1={transformation:n()},this.mountPoint2={transformation:n()},this.mountedAt1WS={x:0,y:0},this.mountedAt2WS={x:0,y:0},this.mountPoint1Translation=n(),this.mountPoint2Translation=n(),this.mountPoint1Rotation=n(),this.mountPoint2Rotation=n(),this.mountedAt1=t.mountedAt1,this.mountedAt2=t.mountedAt2,this.length1=t.length1,this.length2=t.length2,this.extensionLength1=t.extensionLength1,this.extensionLength2=t.extensionLength2,this.flip=t.flip}step(t,i){h(this.mountedAt1WS,{x:0,y:0},this.mountedAt1.transformation),h(this.mountedAt2WS,{x:0,y:0},this.mountedAt2.transformation);let o=d(this.mountedAt1WS,this.mountedAt2WS);if(o<w)throw new Error("Mount points are placed too close to each other.");if(o>this.length1+this.length2)throw new Error("Arms are too short.");let n=p(this.mountedAt1WS,this.length1,this.mountedAt2WS,this.length2),a=this.flip?n[1]:n[0],l=y(a,this.mountedAt1WS),u=y(a,this.mountedAt2WS),m=c(f(l),this.length1+this.extensionLength1),P=c(f(u),this.length2+this.extensionLength2),A=x(this.mountedAt1WS,m),T=x(this.mountedAt2WS,P),S=y(A,this.mountedAt1WS),W=y(T,this.mountedAt2WS),M=g(S),b=g(W);e(this.mountPoint1Rotation,M),e(this.mountPoint2Rotation,b),s(this.mountPoint1Translation,A.x,A.y),s(this.mountPoint2Translation,T.x,T.y),r(this.mountPoint1.transformation,this.mountPoint1Translation,this.mountPoint1Rotation),r(this.mountPoint2.transformation,this.mountPoint2Translation,this.mountPoint2Rotation)}drawDebug(t){let i={x:0,y:0},o={x:0,y:0};h(i,{x:0,y:0},this.mountPoint1.transformation),h(o,{x:0,y:0},this.mountPoint2.transformation),t.beginPath(),t.moveTo(this.mountedAt1WS.x,this.mountedAt1WS.y),t.lineTo(i.x,i.y),t.moveTo(this.mountedAt2WS.x,this.mountedAt2WS.y),t.lineTo(o.x,o.y),t.lineWidth=3,t.strokeStyle="pink",t.stroke(),t.lineWidth=1,a(t,this.mountPoint1.transformation),a(t,this.mountPoint2.transformation)}}class S{constructor(t,i){this.renderContext=t,this.contraptionRenderContext=i,this.objects=[],this.pens=[],this.stepsPerFrame=10,this.frameTime=1/60,this._isRunning=!1,this.simulationTime=0,this.previousStepTimestamp=0}run(){this._isRunning||(this._isRunning=!0,this.processFrame())}stop(){this._isRunning=!1}reset(){this.stop(),this.simulationTime=0,this.previousStepTimestamp=0}get isRunning(){return this._isRunning}processFrame(){this._isRunning&&setTimeout(this.processFrame.bind(this),1e3*this.frameTime);for(let t=0;t<this.stepsPerFrame;++t)this.step(this.simulationTime),this.simulationTime+=this.frameTime/this.stepsPerFrame;this.draw(this.renderContext),this.contraptionRenderContext&&this.drawDebug(this.contraptionRenderContext)}step(t){let i=t-this.previousStepTimestamp;this.previousStepTimestamp=t;for(let o=0;o<this.objects.length;++o)this.objects[o].step(t,i);for(let o=0;o<this.pens.length;++o)this.pens[o].step(t,i)}draw(t){for(let i=0;i<this.pens.length;++i)this.pens[i].draw(t)}drawDebug(t){t.clearRect(0,0,t.canvas.width,t.canvas.height);for(let i=0;i<this.objects.length;++i)this.objects[i].drawDebug(t)}}var W=i.D_,M=i.Gm,b=i.xs,R=i.K4,v=i.z1,B=i.AK,C=i.eh,k=i.LI;export{W as Oscillator,M as Pen,b as Scene,R as StaticMountPoint,v as VArm,B as Wheel,C as XArm,k as easingFunctions};